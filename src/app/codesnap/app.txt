Project Directory: app
Total Files Analyzed: 42
Total Size: 0.07 MB
Date: 2025-02-10T17:37:07.878Z

Token counts and costs by model:
   GPT-3.5: 15.2K tokens → $0.0228
   GPT-4:   15.2K tokens → $0.4558
   Claude:  15.2K tokens → $0.2279
   LLaMA 2: 16.7K tokens → $0.0334

Directory structure:
├── _core/
│   ├── auth/
│   │   ├── guard/
│   │   │   ├── auth.guard.ts
│   │   │   └── non-auth.guard.ts
│   │   └── interception/
│   │       └── auth.interceptor.ts
│   ├── base/
│   │   ├── domain/
│   │   │   ├── clients/
│   │   │   │   └── base.interface.client.ts
│   │   │   └── models/
│   │   │       ├── base-entity-DTO.model.ts
│   │   │       ├── base-entity.abstract.model.ts
│   │   │       ├── filter-event.model.ts
│   │   │       ├── http-options.model.ts
│   │   │       └── ui-paging.model.ts
│   │   ├── gateways/
│   │   │   ├── http/
│   │   │   │   ├── custom-http-params.ts
│   │   │   │   └── http-base.abstract.client.ts
│   │   │   └── mocks/
│   │   │       └── mock-base.abstract.client.ts
│   │   └── use-cases/
│   │       ├── base.abstract.builder.ts
│   │       └── base.abstract.handler.ts
│   ├── error-handler/
│   │   ├── error-handler.ts
│   │   └── http-error-handler.interceptor.ts
│   ├── notification/
│   │   ├── domain/
│   │   │   └── models/
│   │   │       └── notification.model.ts
│   │   └── use-cases/
│   │       └── notification.handler.ts
│   └── utils/
│       └── constants.ts
├── interface/
│   └── contact.interface.ts
├── services/
│   ├── _core/
│   │   ├── auth/
│   │   │   ├── auth.explain.txt
│   │   │   ├── auth.service.spec.ts
│   │   │   └── auth.service.ts
│   │   ├── rest/
│   │   │   ├── rest.service.spec.ts
│   │   │   └── rest.service.ts
│   │   ├── token/
│   │   │   ├── token.service.spec.ts
│   │   │   └── token.service.ts
│   │   ├── route-logging.service.spec.ts
│   │   └── route-logging.service.ts
│   ├── error-test/
│   │   ├── error-test.service.spec.ts
│   │   └── error-test.service.ts
│   ├── image/
│   │   ├── image.service.spec.ts
│   │   └── image.service.ts
│   └── profile-service/
│       ├── profile.interface.ts
│       ├── profile.service.spec.ts
│       └── profile.service.ts
├── app.component.html
├── app.component.scss
├── app.component.spec.ts
├── app.component.ts
├── app.config.ts
└── app.routes.ts

================================================
File: _core/auth/guard/auth.guard.ts
================================================
import { Injectable } from '@angular/core';
import { ActivatedRouteSnapshot, CanActivate, Router } from '@angular/router';
import { catchError, map, Observable, of } from 'rxjs';
import { AuthService } from '../../../services/_core/auth/auth.service';
import { RouteLoggingService } from '../../../services/_core/route-logging.service';

@Injectable({
	providedIn: 'root',
})
export class AuthGuard implements CanActivate {
	constructor(
		private authService: AuthService,
		private router: Router,
		private logger: RouteLoggingService
	) {}

	canActivate(route: ActivatedRouteSnapshot): Observable<boolean> {
		const path = route.routeConfig?.path || 'unknown';
		this.logger.logGuardCheck('AuthGuard', path);

		return this.authService.getCurrentUser().pipe(
			map((user) => {
				if (user) {
					this.logger.logGuardResult('AuthGuard', true);

					if (route.routeConfig?.path === 'login') {
						this.logger.logRouteHit('Redirecting to dashboard');
						this.router.navigate(['/dashboard']);
						return false;
					}
					return true;
				}

				this.logger.logGuardResult('AuthGuard', false);
				if (route.routeConfig?.path !== 'login') {
					this.logger.logRouteHit('Redirecting to login');
					this.router.navigate(['/login']);
				}
				return route.routeConfig?.path === 'login';
			}),
			catchError((error) => {
				console.error('🔴 AuthGuard Error:', error);
				this.router.navigate(['/login']);
				return of(false);
			})
		);
	}
}


================================================
File: _core/auth/guard/non-auth.guard.ts
================================================
import { Injectable } from '@angular/core';
import { Router, UrlTree } from '@angular/router';
import { Observable, of } from 'rxjs';
import { AuthService } from '../../../services/_core/auth/auth.service';

@Injectable({
	providedIn: 'root',
})
export class NonAuthGuard {
	constructor(private auth: AuthService, private router: Router) {}

	canActivate(): Observable<boolean | UrlTree> {
		return of(true);
	}
}


================================================
File: _core/auth/interception/auth.interceptor.ts
================================================
import {
	HttpErrorResponse,
	HttpEvent,
	HttpHandler,
	HttpInterceptor,
	HttpRequest,
} from '@angular/common/http';
import { Injectable } from '@angular/core';
import { TEST_View } from '@environments/environment.development';
import { catchError, Observable, switchMap, throwError } from 'rxjs';
import { AuthService } from '../../../services/_core/auth/auth.service';
import { TokenService } from '../../../services/_core/token/token.service';

@Injectable()
export class AuthInterceptor implements HttpInterceptor {
	constructor(
		private authService: AuthService,
		private tokenService: TokenService
	) {}

	intercept(
		req: HttpRequest<any>,
		next: HttpHandler
	): Observable<HttpEvent<any>> {
		console.log('Auth Interceptor - Starting interception');
		return next.handle(req).pipe(
			catchError((error: HttpErrorResponse) => {
				if (error.status === 401) {
					return this.tokenService.refreshIdToken().pipe(
						switchMap(() => next.handle(req)),
						catchError((refreshError) => {
							this.authService.logout();
							if (TEST_View.interceptor__error_detail_log) {
								return throwError(() => refreshError);
							} else {
								return throwError(
									() => new Error('Erreur de rafraîchissement du token')
								);
							}
						})
					);
				}
				if (error.status === 404) {
					console.log('Erreur 404');
					if (TEST_View.interceptor__error_detail_log) {
						return throwError(() => error);
					} else {
						return throwError(() => new Error('Ressource non trouvée'));
					}
				}
				if (TEST_View.interceptor__error_detail_log) {
					return throwError(() => error);
				} else {
					return throwError(() => new Error('Erreur inconnue'));
				}
			})
		);
	}
}


================================================
File: _core/base/domain/clients/base.interface.client.ts
================================================
import { Observable } from 'rxjs';
import { BaseEntity } from '@core/base/domain/models/base-entity.abstract.model';
import { FilterEvent } from '@core/base/domain/models/filter-event.model';
import { KeyValueObject } from '@ui/shared/models/utils.model';

/**
 * L'interface `AbstractBaseClient` définit les méthodes qui devront être implémentées par les classes qui manipulant les données et qui extends cette interface.
 * C'est notre contrat pour manipuler les données.
 * @param {T} T extends BaseEntity L'entité manipulée.
 * @param {F} F extends FilterEvent Le filtre utilisé pour récupérer les entités.
 */
export abstract class AbstractBaseClient<
	T extends BaseEntity,
	F extends FilterEvent
> {
	/**
	 * La méthode `all` est utilisée pour récupérer tous les éléments.
	 * Elle doit retourner un Observable qui émet un tableau d'éléments.
	 * @param {F} filters Les filtres utilisés pour récupérer les éléments.
	 * @returns {Observable<T[]>} Un Observable qui émet un tableau d'éléments.
	 */
	abstract all(filters?: F): Observable<T[]>;

	/**
	 * La méthode `get` est utilisée pour récupérer un élément avec l'ID passé en param.
	 * Elle retourne un Observable avec le bon élément ou une erreur si le élément n'est pas trouvé.
	 * @param {string} id L'ID de l'élément à récupérer.
	 * @param {KeyValueObject} options Les paramètres additionnels.
	 * @returns {Observable<T>} Un Observable qui émet un le élément récupéré.
	 */
	abstract get(id: string, options?: KeyValueObject): Observable<T>;

	/**
	 * La méthode `create` est utilisée pour créer un élément.
	 * Elle retourne un Observable avec le nouvel élément ou une erreur si la création a échoué.
	 * @param {T} entity L'élément à créer.
	 * @returns {Observable<T | void>} Un Observable qui émet le nouvel élément créé ou rien du tout.
	 */
	abstract create(entity: T): Observable<T | void>;

	/**
	 * La méthode `update` est utilisée pour mettre à jour un élément.
	 * Elle retourne un Observable avec l'élément mis à jour ou une erreur si la mise à jour a échoué.
	 * @param {T} entity L'élément à mettre à jour.
	 * @returns {Observable<T | void>} Un Observable qui émet l'élément mis à jour ou rien du tout.
	 */
	abstract update(entity: T): Observable<T | void>;

	/**
	 * La méthode `delete` est utilisée pour supprimer un élément.
	 * Elle retourne un Observable avec un message de succès ou une erreur si la suppression a échoué.
	 * @param {string | T} id  L'ID de l'entité à supprimer.
	 * @param {T} entity  Facultatif: L'entité à supprimer (utilisé dans le cas des entité avec un State).
	 * @returns {Observable<void>}
	 */
	abstract delete(id: string, entity?: T): Observable<void>;
}


================================================
File: _core/base/domain/models/base-entity-DTO.model.ts
================================================
export interface BaseEntityDTO {
    [key: string]: unknown;
}


================================================
File: _core/base/domain/models/base-entity.abstract.model.ts
================================================
import { KeyValueObject } from '@ui-shared/models/utils.model';

/**
 * Class permettant de définir les information partagé pour une entité.
 */
export abstract class BaseEntity {
    constructor(private _json: KeyValueObject) {}

    get json(): KeyValueObject {
        return this._json;
    }

    get id(): string {
        return this._json['id'] as string;
    }

    get isEdited(): boolean {
        return this._json['isEdited'] as boolean;
    }
}


================================================
File: _core/base/domain/models/filter-event.model.ts
================================================
import { Sort } from '@angular/material/sort';
import { MAX_LENGTH_PAGING } from '@utils/constants';
import { UiPaging } from './ui-paging.model';

export class FilterEvent {
    /**
     * Pagination
     */
    paging?: UiPaging;

    /**
     *  Tri
     */
    sort?: Sort;

    /**
     * Filtres
     */
    filters?: Filter[];

    /**
     * Terme de recherche
     */
    searchText?: string;

    constructor(
        sort?: Sort,
        searchText?: string,
        paging?: UiPaging,
        filters: Filter[] = []
    ) {
        this.sort = sort;
        this.filters = filters;
        this.searchText = searchText ?? '';
        this.paging = paging;
    }

    /**
     * Récuperation d'une valeur de filtre
     * @param {string} name Nom du filtre
     * @returns {T | undefined} Valeur du filtre
     */
    public getFilterDefinition<T>(name: string): T | undefined {
        return this.getFilter(name)?.definition as T;
    }

    /**
     * Récuperation d'une valeur de filtre
     * @param {string} name Nom du filtre
     * @returns {T | undefined} Valeur du filtre
     */
    public getFilter(name: string): Filter | undefined {
        return this.filters?.find(filter => filter.name === name);
    }

    /**
     * Ajout d'un filtre
     * @param {string} name Nom du filtre
     * @param {T} definition Definition du filtre
     * @param {boolean} additional Indique si le filtre est additionnel
     * @returns {FilterEvent}
     */
    public setFilter<T>(
        name: string,
        definition: T,
        additional?: boolean
    ): FilterEvent {
        const filter = this.getFilter(name);
        if (filter) {
            filter.definition = definition;
        } else {
            this.filters?.push(new Filter(name, definition, additional));
        }
        return this;
    }

    /**
     * Suprime le filtre suivant le nom passé en paramètre
     * @param {string} name Nom du filtre à supprimer
     * @returns {FilterEvent} Instance de l'objet
     */
    public deleteFilter(name: string): FilterEvent {
        this.filters = this.filters?.filter(f => f.name !== name);
        return this;
    }

    /**
     * Supprimer tous les filtres
     * @returns {FilterEvent} Instance de l'objet
     */
    public clearFilters(): FilterEvent {
        this.filters = [];
        return this;
    }

    /**
     * Transforme l'objet en DTO
     * @returns {FilterDto} DTO
     */
    public transformToDTO(): FilterDto {
        return new FilterDto(
            this.paging?.offset,
            this.paging?.range,
            this.sort
                ? [
                      {
                          name: this.sort?.active,
                          descending: this.sort?.direction === 'desc',
                      },
                  ]
                : undefined,
            // Si la définition du filtre est un tableau, on l'envoie sous forme de string
            this.filters
                ? this.filters?.map(filter => {
                      return {
                          name: filter.name,
                          definition: Array.isArray(filter.definition)
                              ? filter.definition.join(',')
                              : filter.definition,
                      };
                  })
                : undefined
        );
    }
}

export class Filter {
    /**
     * Nom du filtre
     */
    name: string;

    /**
     * Définition du filtre (valeur simple ou array)
     */
    definition: unknown;

    /**
     * Filtre additionnel
     */
    additional: boolean;

    constructor(
        name: string,
        definition: unknown,
        additional: boolean = false
    ) {
        this.name = name;
        this.definition = definition;
        this.additional = additional;
    }
}

export interface Order {
    name: string;
    descending: boolean;
}

export class FilterDto {
    firstLineIndex?: number;
    linesCount?: number;
    orders?: Order[];
    filters?: { name: string; definition: unknown }[];

    constructor(
        firstLineIndex?: number,
        linesCount?: number,
        orders?: Order[],
        filters?: { name: string; definition: unknown }[]
    ) {
        this.firstLineIndex = firstLineIndex ?? 0;
        this.linesCount = linesCount ?? MAX_LENGTH_PAGING;
        this.orders = orders ?? [];
        this.filters = filters ?? [];
    }
}


================================================
File: _core/base/domain/models/http-options.model.ts
================================================
import { HttpContext, HttpHeaders } from '@angular/common/http';
import { CustomHttpParams } from '@core/base/gateways/http/custom-http-params';

export class HttpOptions {
    headers?:
        | HttpHeaders
        | {
              [header: string]: string | string[];
          };
    context?: HttpContext;
    observe?: string = 'body';
    params?:
        | CustomHttpParams
        | {
              [param: string]:
                  | string
                  | number
                  | boolean
                  | ReadonlyArray<string | number | boolean>;
          };
    reportProgress?: boolean;
    responseType: string = 'json';
    withCredentials?: boolean;
    transferCache?:
        | {
              includeHeaders?: string[];
          }
        | boolean;
}


================================================
File: _core/base/domain/models/ui-paging.model.ts
================================================
import { MAX_LENGTH_PAGING } from '@utils/constants';

export class UiPaging {
    /**
     * Numéro de la première ligne ou page (0 par default)
     */
    offset: number;

    /**
     * Nombre d'éléments chargé ou nombre d'éléments par page (MAX_LENGTH_PAGING par default)
     */
    range: number;

    /**
     * Nombre d'éléments total
     */
    count: number;

    /**
     * Permet de savoir si on est en pagination lazyloadé
     */
    lazyLoading: boolean;

    constructor(
        lazyLoading = true,
        offset = 0,
        range = MAX_LENGTH_PAGING,
        count = 0
    ) {
        this.offset = offset;
        this.range = range;
        this.count = count;
        this.lazyLoading = lazyLoading;
    }
}


================================================
File: _core/base/gateways/http/custom-http-params.ts
================================================
import { HttpParams } from '@angular/common/http';

export class CustomHttpParams {
    private httpParams: HttpParams = new HttpParams();

    /**
     * Le constructeur prend optionnellement un nom et un valeur pour une définition directe d'un paramètre.
     * @param {string} name Nom du paramètre
     * @param {string | number | boolean} value  Valeur du paramètre
     */
    constructor(name?: string, value?: string | number | boolean) {
        if (name != null) {
            this.httpParams = this.httpParams.set(name, <string>value);
        }
    }

    /**
     * Ajoute un paramètre en utilisant toString. Le name et la valeur doivent exister.
     * @param {string} name Nom du paramètre
     * @param {string | number | boolean} value Valeur du paramètre (format string, number ou boolean, pour les dates, utiliser les fonctions correspondantes)
     */
    public setValue(
        name: string,
        value: string | number | boolean
    ): CustomHttpParams {
        if (value != null && name !== undefined) {
            this.httpParams = this.httpParams.append(name, <string>value);
        }
        return this;
    }

    /**
     * Permets d'ajouter un paramètre de type array de string ou de number
     * @param {string} name Nom du paramètre
     * @param {unknown[]} value Valeur du paramètre
     */
    public setStringArrayValue(
        name: string,
        value: unknown[]
    ): CustomHttpParams {
        if (value !== null && name !== undefined) {
            this.httpParams = this.httpParams.append(
                name,
                JSON.stringify(value)
            );
        }
        return this;
    }

    /**
     * Récupère les paramètres HTTP
     * @returns {HttpParams}
     */
    public getParams(): HttpParams {
        return this.httpParams;
    }
}


================================================
File: _core/base/gateways/http/http-base.abstract.client.ts
================================================
import { HttpClient, HttpContext, HttpHeaders } from '@angular/common/http';
import { inject } from '@angular/core';
import { HttpOptions } from '@core/base/domain/models/http-options.model';
import { CustomHttpParams } from '@core/base/gateways/http/custom-http-params';
import { Observable } from 'rxjs';
import URI from 'urijs';

/**
 * La classe abstraite `AbstractHttpBaseClient` contient les méthodes partagées par les clients (services appelant les api) utilisant le protocole HTTP.
 */
export abstract class AbstractHttpBaseClient {
    private readonly http = inject(HttpClient);

    protected abstract basePathApi: string | undefined;

    /**
     * Création d'une URL à partir d'un chemin et de paramètres
     * @param {path} path Chemin de l'URL
     * @param {parameters} parameters Paramètres de l'URL
     * @returns {string} URL complète
     */
    public makeURL(path: string, parameters?: string): string {
        let url = ConfigUrl.makeURL(
            this.basePathApi ? `${this.basePathApi}/${path}` : path
        );

        if (parameters) {
            url += '?' + parameters;
        }

        return url;
    }

    /**
     * Crée un objet de paramètres pour les url à partir d'un nom et d'une valeur
     * @param {string} name Nom du paramètre
     * @param {string} value Valeur du paramètre
     * @returns {CustomHttpParams}
     */
    protected _makeSimpleParam(name: string, value: string): CustomHttpParams {
        const params = new CustomHttpParams().setValue(name, value);
        return params;
    }

    /**
     * Crée un objet RequestOptions initialisé
     * @param {CustomHttpParams} httpParams Tableau de paramètres
     * @param {boolean} withCredentials Indique si on veut envoyer les cookies (par défaut true)
     * @param {boolean} withResponse Indique si on veut récupérer la réponse entière (par défaut false)
     * @param {string} responseType Type de réponse attendue (par défaut 'json')
     * @returns {HttpOptions}
     */
    protected _getOptions(
        httpParams?: CustomHttpParams,
        headers?: HttpHeaders,
        withCredentials: boolean = true,
        withResponse: boolean = false,
        responseType: string = 'json'
    ): HttpOptions {
        const options: HttpOptions = {
            context: new HttpContext(),
            params: httpParams?.getParams() as CustomHttpParams | undefined,
            responseType: responseType,
            withCredentials: withCredentials,
            observe: withResponse ? 'response' : 'body',
        };

        if (headers) {
            options.headers = headers;
        }

        return options;
    }

    /**
     * Url complète à partir de la base du service transmise au constructeur et de la config générale.
     * @param {string} service Nom du service à appeler
     * @returns {string} URL complète
     */
    protected _getURL(service: string): string {
        return this.makeURL(service);
    }

    /**
     * Appelle le service par la méthode HttpGet
     * @param {string} service Le nom du service a appeler
     * @param {CustomHttpParams | string} param Tableau de paramètres (HttpParams) ou string donnant la valeur du paramètre ID
     */
    protected _get<T>(
        service: string,
        param?: CustomHttpParams | string,
        headers?: HttpHeaders,
        responseType?: string
    ): Observable<T> {
        const httpParams: CustomHttpParams | undefined = param
            ? typeof param === 'string'
                ? this._makeSimpleParam('id', param)
                : param
            : undefined;

        return this.http.get<T>(
            this._getURL(service),
            this._getOptions(
                httpParams,
                headers,
                true,
                false,
                responseType
            ) as object
        );
    }

    /**
     * Appelle le service par la méthode HttpPost et passe les données
     * @param {string} service Le nom du service a appeler
     * @param {unknown} data Les données à envoyer
     * @param {CustomHttpParams | string} param Tableau de paramètres (HttpParams) ou string donnant la valeur du paramètre ID
     */
    protected _post<T>(
        service: string,
        data: unknown,
        param?: CustomHttpParams | string,
        headers?: HttpHeaders
    ): Observable<T> {
        const httpParams: CustomHttpParams | undefined = param
            ? typeof param === 'string'
                ? this._makeSimpleParam('id', param)
                : param
            : undefined;
        return this.http.post<T>(
            this._getURL(service),
            data,
            this._getOptions(httpParams, headers) as object
        );
    }

    /**
     * Appelle le service par la méthode HttpPut et passe les données
     * @param {string} service Le nom du service a appeler
     * @param {unknown} data Les données à envoyer
     * @param {CustomHttpParams | string} param Tableau de paramètres (HttpParams) ou string donnant la valeur du paramètre ID
     */
    protected _put<T>(
        service: string,
        data: unknown,
        param?: CustomHttpParams | string
    ): Observable<T> {
        const httpParams: CustomHttpParams | undefined = param
            ? typeof param === 'string'
                ? this._makeSimpleParam('id', param)
                : param
            : undefined;

        return this.http.put<T>(
            this._getURL(service),
            data,
            this._getOptions(httpParams) as object
        );
    }

    /**
     * Appelle le service par la méthode HttpDelete
     * @param {string} service Le nom du service a appeler
     * @param {CustomHttpParams | string} param Tableau de paramètres (HttpParams) ou string donnant la valeur du paramètre ID
     */
    protected _delete<T>(
        service: string,
        param?: CustomHttpParams | string
    ): Observable<T> {
        const httpParams: CustomHttpParams | undefined = param
            ? typeof param === 'string'
                ? this._makeSimpleParam('id', param)
                : param
            : undefined;
        return this.http.delete<T>(
            this._getURL(service),
            this._getOptions(httpParams) as object
        );
    }
}

class ConfigUrl {
    public static makeURL(path: string, parameters: object = {}): string {
        return URI(`api/${path}`).search(parameters).normalize().toString();
    }
}


================================================
File: _core/base/gateways/mocks/mock-base.abstract.client.ts
================================================
import { BaseEntity } from '@core/base/domain/models/base-entity.abstract.model';
import { FilterEvent } from '@core/base/domain/models/filter-event.model';
import { BehaviorSubject, Observable, Subject, map, tap } from 'rxjs';

/**
 * La classe `AbstractMockBaseClient` est une une classe abstraite permettant les implémentations des interface client et qui sont partagées
 * Elle va permettre de simuler des comportements dans un environnement mockée ou de développement lorsque l'implémentation via le protocole HTTP n'est pas encore disponible.
 */
export abstract class AbstractMockBaseClient<
    B extends BaseEntity,
    F extends FilterEvent,
> {
    protected _entities$: Subject<B[]> = new BehaviorSubject<B[]>(
        this._entities
    );

    constructor(protected _entities: B[] = []) {}

    /**
     * La méthode `all` est utilisée pour récupérer toutes les entité.
     * Dans cette implémentation mockée, elle retourne un Observable d'un tableau vide ou contenant toutes les entités que l'on aura settées via le constructeur.
     * @returns {Observable<B[]>} Un Observable qui émet un tableau vide ou contenant toutes les entités.
     */
    public all(filters?: F): Observable<B[]> {
        if (filters) {
            return this.filterEntities(filters);
        } else {
            return this._entities$;
        }
    }

    /**
     * Implémentation de la méthode générique de filtre des entités pour les mocks uniquement sur les champs texte.
     * @param filters
     */
    protected filterEntities(filters: F): Observable<B[]> {
        if (filters) {
            const filteredEntities = this._entities.filter(value => {
                if (!filters.searchText) {
                    return true;
                } else {
                    return Object.keys(value).some(key => {
                        return (
                            !!value[key as keyof typeof value] &&
                            String(value[key as keyof typeof value])
                                .toLowerCase()
                                .includes(
                                    filters?.searchText?.toLowerCase() ?? ''
                                )
                        );
                    });
                }
            });
            this._entities$.next(filteredEntities);
        }
        return this._entities$;
    }

    /**
     * La méthode `get` est utilisée pour récupérer une entité avec l'ID passé en param.
     * Dans cette implémentation mockée, elle retourne un Observable avec la bonne entité parmis celles que l'on aura settée via le constructeur ou une erreur si elle n'est pas trouvée.
     * @param {string} id  L'ID de l'entité à récupérer.
     * @returns {Observable<B>} Un Observable qui émet un la bonne entité récupéré.
     */
    public get(id: string): Observable<B> {
        return this._entities$.pipe(
            map((bases: B[]) => bases.find((base: B) => base.id === id) as B),
            tap(result => {
                if (!result) {
                    throw new Error(
                        `Aucun objet n'a été trouvé avec l'ID: ${id}`
                    );
                }
            })
        );
    }

    /**
     * La méthode `create` est utilisée pour créer une entité.
     * Dans cette implémentation mockée, elle retourne un Observable avec la nouvelle entité ou une erreur si la création a échoué.
     * @param {B} entity L'entité à créer.
     * @returns {Observable<B>} Un Observable qui émet la nouvelle entité créée.
     */
    public create(entity: B): Observable<B> {
        this._entities.push(entity);
        this._entities$.next(this._entities);
        return new Observable<B>(subscriber => {
            subscriber.next(entity);
            subscriber.complete();
        });
    }

    /**
     * La méthode `update` est utilisée pour mettre à jour une entité.
     * Dans cette implémentation mockée, elle retourne un Observable avec l'entité mise à jour ou une erreur si la mise à jour a échoué.
     * @param {B} entity L'entité à mettre à jour.
     * @returns {Observable<B>} Un Observable qui émet l'entité mise à jour.
     */
    public update(entity: B): Observable<B> {
        const index = this._entities.findIndex(
            (base: B) => base.id === entity.id
        );
        if (index === -1) {
            throw new Error(
                `Aucun objet n'a été trouvé avec l'ID: ${entity.id}`
            );
        }
        this._entities[index] = entity;
        this._entities$.next(this._entities);
        return new Observable<B>(subscriber => {
            subscriber.next(entity);
            subscriber.complete();
        });
    }

    /**
     * La méthode `delete` est utilisée pour supprimer une entité.
     * Dans cette implémentation mockée, elle retourne un Observable avec un message de succès ou une erreur si la suppression a échoué.
     * @param {string} is Id de l''entité à supprimer.
     * @returns {Observable<void>}
     */
    public delete(id: string): Observable<void> {
        const index = this._entities.findIndex((base: B) => base.id === id);
        if (index === -1) {
            throw new Error(`Aucun objet n'a été trouvé avec l'ID: ${id}`);
        }
        this._entities.splice(index, 1);
        this._entities$.next(this._entities);
        return new Observable<void>(subscriber => {
            subscriber.complete();
        });
    }
}


================================================
File: _core/base/use-cases/base.abstract.builder.ts
================================================
import { BaseEntity } from '@core/base/domain/models/base-entity.abstract.model';
import { KeyValueObject } from '@ui-shared/models/utils.model';

/**
 * La classe `AbstractBaseBuilder` permet d'avoir un constructeur de l'objet `T extends BaseEntity` avec un simple object json.
 * Elle utilise le pattern Builder pour créer des instances de `T extends BaseEntity`.
 */
export abstract class AbstractBaseBuilder<T extends BaseEntity> {
    protected _json: KeyValueObject = {};
    protected _id: string = '';

    /**
     * Initialiser l'instance avec l'objet json en entrée
     * @param {KeyValueObject} json
     * @returns
     */
    public withJsonObj(json: KeyValueObject): this {
        // Si l'objet json est une chaine de caractère, on le transforme en objet
        if (typeof json === 'string') {
            json = { id: json };
        }

        this._json = json;
        this._id = json['id'] as string;
        return this;
    }

    /**
     * Construire et renvoyer l'instance de `T extends BaseEntity`
     */
    abstract build(): T;
}


================================================
File: _core/base/use-cases/base.abstract.handler.ts
================================================
import { AbstractBaseClient } from '@core/base/domain/clients/base.interface.client';
import { BaseEntity } from '@core/base/domain/models/base-entity.abstract.model';
import { FilterEvent } from '@core/base/domain/models/filter-event.model';
import { KeyValueObject } from '@ui/shared/models/utils.model';
import { Observable } from 'rxjs';

/**
 * La classe abstraite `AbstractBaseHandler` permet d'avoir les méthodes utilisées par un gestionnaire de données
 * Elle définit les cas d'utilisation partagés pour les entités.
 */
export abstract class AbstractBaseHandler<
    T extends BaseEntity,
    F extends FilterEvent,
> {
    constructor(protected _client: AbstractBaseClient<T, F>) {}

    /**
     * La méthode `all` est utilisée pour récupérer toutes les entités de type T extends BaseEntity.
     * Elle appelle le client correspondant pour récupérer toutes les entités de type T extends BaseEntity ou afficher l'erreure correspondante.
     * @returns {Observable<T[]>} Un Observable qui émet un tableau vide ou remplis d'entités.
     */
    public all(filters?: F): Observable<T[]> {
        return this._client.all(filters);
    }

    /**
     * La méthode `get` est utilisée pour récupérer une entité avec l'ID passé en param.
     * Elle appelle le client correspondant pour récupérer une entité ou afficher l'erreure correspondante.
     * @param {strind} id L'ID de l'entité à récupérer.
     * @param {KeyValueObject} options Les paramètres additionnels.
     * @returns {Observable<T>} Un Observable qui émet l'entité récupéré.
     */
    public get(id: string, options?: KeyValueObject): Observable<T> {
        return this._client.get(id, options);
    }

    /**
     * La méthode `update` est utilisée pour mettre à jour un élément.
     * Elle retourne un Observable avec l'élément mis à jour ou une erreur si la mise à jour a échoué.
     * @param {T} Entity L'élément à mettre à jour.
     * @returns {Observable<T | void>} Un Observable qui émet l'élément mis à jour ou rien.
     */
    public create(entity: T): Observable<T | void> {
        return this._client.create(entity);
    }

    /**
     * La méthode `update` est utilisée pour mettre à jour un élément.
     * Elle retourne un Observable avec l'élément mis à jour ou une erreur si la mise à jour a échoué.
     * @param {T} entity L'élément à mettre à jour.
     * @returns {Observable<T | void>} Un Observable qui émet l'élément mis à jour ou rien.
     */
    public update(entity: T): Observable<T | void> {
        return this._client.update(entity);
    }

    /**
     * La méthode `delete` est utilisée pour supprimer un élément.
     * Elle retourne un Observable avec un message de succès ou une erreur si la suppression a échoué.
     * @param {string} id Id de l'élément à supprimer.
     * @param {T} entity  Facultatif: L'entité à supprimer (utilisé dans le cas des entité avec un State).
     * @returns {Observable<void>}
     */
    public delete(id: string, entity?: T): Observable<void> {
        return this._client.delete(id, entity);
    }
}


================================================
File: _core/error-handler/error-handler.ts
================================================
import { HttpErrorResponse } from '@angular/common/http';
import { ErrorHandler, Injectable, NgZone, inject } from '@angular/core';
import { NotificationHandler } from '@core/notification/use-cases/notification.handler';

@Injectable()
export class AppErrorHandler implements ErrorHandler {
    private notificationService: NotificationHandler =
        inject(NotificationHandler);

    constructor(private zone: NgZone) {}

    handleError(error: unknown): void {
        console.error('Caught by Custom Error Handler: ', error);

        if (!(error instanceof HttpErrorResponse)) {
            this.zone.run(() => {
                this.notificationService.danger({
                    messageKeyTrad: 'ERROR.UNKNOW',
                });
            });
        }
    }
}


================================================
File: _core/error-handler/http-error-handler.interceptor.ts
================================================
import {
	HttpErrorResponse,
	HttpEvent,
	HttpHandler,
	HttpInterceptor,
	HttpRequest,
	HttpStatusCode,
} from '@angular/common/http';
import { Injectable, inject } from '@angular/core';
import { NotificationHandler } from '@core/notification/use-cases/notification.handler';
import {
	MonoTypeOperatorFunction,
	Observable,
	OperatorFunction,
	throwError,
	timer,
} from 'rxjs';
import { catchError, retry } from 'rxjs/operators';
import { AuthService } from '../../services/_core/auth/auth.service';
import { Router } from '@angular/router';

function retryWithDelay(count: number): MonoTypeOperatorFunction<unknown> {
	return retry({
		count,
		delay: (error, retryCount) => timer(retryCount * 1000),
	});
}

@Injectable()
export class HttpErrorInterceptor implements HttpInterceptor {
	private readonly MAX_RETRIES = 2;
	private readonly RETRY_STATUS_CODES = [
		HttpStatusCode.GatewayTimeout,
		HttpStatusCode.ServiceUnavailable,
		HttpStatusCode.BadGateway,
	];

	constructor(
		private notificationService: NotificationHandler,
		private authService: AuthService,
		private router: Router
	) {}

	intercept(
		request: HttpRequest<any>,
		next: HttpHandler
	): Observable<HttpEvent<any>> {
		return next.handle(request).pipe(
			retry({
				count: this.MAX_RETRIES,
				delay: (error, retryCount) => {
					if (
						error instanceof HttpErrorResponse &&
						this.RETRY_STATUS_CODES.includes(error.status)
					) {
						// Exponential backoff retry delay
						const retryDelay = Math.pow(2, retryCount) * 1000;
						return timer(retryDelay);
					}
					return throwError(() => error);
				},
			}),
			catchError((error: HttpErrorResponse) => {
				return this.handleError(error, request);
			})
		);
	}

	private handleError(
		error: HttpErrorResponse,
		request: HttpRequest<any>
	): Observable<never> {
		// Don't show errors for cancelled requests
		if (
			error instanceof HttpErrorResponse &&
			error.status === 0 &&
			error.error instanceof ProgressEvent
		) {
			// Request was cancelled
			return throwError(() => error);
		}

		let errorMessage = this.getErrorMessage(error);
		const errorResponse = {
			statusCode: error.status,
			message: errorMessage,
			url: request.url,
			timestamp: new Date().toISOString(),
			details: this.getErrorDetails(error),
		};

		// Log error for debugging
		console.error('HTTP Error:', errorResponse);

		// Handle specific status codes
		switch (error.status) {
			case HttpStatusCode.Unauthorized:
				this.handleUnauthorized();
				break;

			case HttpStatusCode.Forbidden:
				this.handleForbidden();
				break;

			case HttpStatusCode.NotFound:
				this.handleNotFound(errorMessage);
				break;

			case HttpStatusCode.BadRequest:
				this.handleBadRequest(error, errorMessage);
				break;

			case HttpStatusCode.UnprocessableEntity:
				this.handleValidationError(error);
				break;

			case 0:
				this.handleNetworkError();
				break;

			case HttpStatusCode.InternalServerError:
				this.handleServerError();
				break;

			default:
				this.handleGenericError(errorMessage);
				break;
		}

		return throwError(() => errorResponse);
	}

	private getErrorMessage(error: HttpErrorResponse): string {
		if (error.error instanceof ErrorEvent) {
			// Client-side error
			return error.error.message;
		}

		// Server-side error
		if (typeof error.error === 'string') {
			return error.error;
		}

		if (error.error?.message) {
			return error.error.message;
		}

		if (Array.isArray(error.error?.errors)) {
			return error.error.errors.map((e: any) => e.message).join('. ');
		}

		return error.message;
	}

	private getErrorDetails(error: HttpErrorResponse): any {
		if (error.error instanceof ErrorEvent) {
			return {
				errorType: 'Client Error',
				stack: error.error.error?.stack,
			};
		}

		return {
			errorType: 'Server Error',
			error: error.error,
		};
	}

	private handleUnauthorized(): void {
		this.notificationService.danger({
			messageKeyTrad: 'ERROR.SESSION_EXPIRED',
			duration: 5000,
		});
		this.authService.logout();
		this.router.navigate(['/login']);
	}

	private handleForbidden(): void {
		this.notificationService.danger({
			messageKeyTrad: 'ERROR.FORBIDDEN',
			duration: 5000,
		});
		this.router.navigate(['/dashboard']);
	}

	private handleNotFound(message: string): void {
		this.notificationService.warning({
			messageKeyTrad: message || 'ERROR.NOT_FOUND',
			duration: 5000,
		});
	}

	private handleBadRequest(error: HttpErrorResponse, message: string): void {
		if (error.error?.errors && Array.isArray(error.error.errors)) {
			// Handle validation errors
			error.error.errors.forEach((validationError: any) => {
				this.notificationService.warning({
					messageKeyTrad: validationError.message,
					duration: 5000,
				});
			});
		} else {
			this.notificationService.warning({
				messageKeyTrad: message || 'ERROR.BAD_REQUEST',
				duration: 5000,
			});
		}
	}

	private handleValidationError(error: HttpErrorResponse): void {
		const validationErrors = error.error?.errors || [];
		validationErrors.forEach((validationError: any) => {
			this.notificationService.warning({
				messageKeyTrad: validationError.message,
				duration: 5000,
			});
		});
	}

	private handleNetworkError(): void {
		this.notificationService.danger({
			messageKeyTrad: 'ERROR.NETWORK',
			duration: 5000,
		});
	}

	private handleServerError(): void {
		this.notificationService.danger({
			messageKeyTrad: 'ERROR.SERVER',
			duration: 5000,
		});
	}

	private handleGenericError(message: string): void {
		this.notificationService.danger({
			messageKeyTrad: message || 'ERROR.GENERIC',
			duration: 5000,
		});
	}
}


================================================
File: _core/notification/domain/models/notification.model.ts
================================================
export interface Notification {
    id: string;
    type: 'info' | 'success' | 'warning' | 'danger';
    messageKeyTrad: string;
    duration?: number;
    autoDismiss?: boolean;
}


================================================
File: _core/notification/use-cases/notification.handler.ts
================================================
import { Notification } from '@core/notification/domain/models/notification.model';
import { NOTIFICATION_DURATION } from '@utils/constants';
import { BehaviorSubject, of, timer } from 'rxjs';
import { filter, switchMap, takeUntil, tap } from 'rxjs/operators';

/**
 * Classe de service de notification.
 * Gère la création et la suppression des notifications.
 */
export class NotificationHandler {
    /**
     * Un BehaviorSubject qui émet un tableau de notifications.
     */
    public notifications$ = new BehaviorSubject<Notification[]>([]);

    constructor() {}

    /**
     * Crée une notification avec un type et un contenu spécifique.
     * @param {Notification['type']} type - Le type de la notification ('info' | 'success' | 'warning' | 'danger').
     * @param {Omit<Notification, 'id' | 'type'>} notification - Les détails de la notification (Type Notification sans id et type).
     */
    private createOne(
        type: Notification['type'],
        notification: Omit<Notification, 'id' | 'type'>
    ) {
        if (!notification) return;

        const notificationItem: Required<Notification> = {
            id: `notification-${Date.now()}`,
            type,
            duration: NOTIFICATION_DURATION,
            autoDismiss: true,
            ...notification,
        };

        of(notificationItem)
            .pipe(
                tap(notification =>
                    this.notifications$.next([
                        ...this.notifications$.value,
                        notification,
                    ])
                ),
                filter(notification => notification.autoDismiss),
                switchMap(() =>
                    timer(notificationItem.duration).pipe(
                        takeUntil(
                            this.notifications$.pipe(
                                filter(
                                    notifications =>
                                        !notifications.includes(
                                            notificationItem
                                        )
                                )
                            )
                        )
                    )
                ),
                tap(() => this.remove(notificationItem))
            )
            .subscribe();
    }

    /**
     * Crée une notification de type 'info'.
     * @param {Omit<Notification, 'id' | 'type'>} notification - Les détails de la notification (Type Notification sans id et type).
     */
    info(notification: Omit<Notification, 'id' | 'type'>): void {
        this.createOne('info', notification);
    }

    /**
     * Crée une notification de type 'success'.
     * @param {Omit<Notification, 'id' | 'type'>} notification - Les détails de la notification (Type Notification sans id et type).
     */
    success(notification: Omit<Notification, 'id' | 'type'>): void {
        this.createOne('success', notification);
    }

    /**
     * Crée une notification de type 'warning'.
     * @param {Omit<Notification, 'id' | 'type'>} notification - Les détails de la notification (Type Notification sans id et type).
     */
    warning(notification: Omit<Notification, 'id' | 'type'>): void {
        this.createOne('warning', notification);
    }

    /**
     * Crée une notification de type 'danger'.
     * @param {Omit<Notification, 'id' | 'type'>} notification - Les détails de la notification (Type Notification sans id et type).
     */
    danger(notification: Omit<Notification, 'id' | 'type'>): void {
        this.createOne('danger', notification);
    }

    /**
     * Supprime une notification spécifique.
     * @param {Notification} notification - La notification à supprimer.
     */
    remove(notification: Notification) {
        if (!notification) return;

        this.notifications$.next(
            this.notifications$.value.filter(
                item => item.id !== notification.id
            )
        );
    }
}


================================================
File: _core/utils/constants.ts
================================================
export const NOTIFICATION_DURATION: number = 8000;
export const MAX_LENGTH_PAGING: number = 20;


================================================
File: app.component.html
================================================
<router-outlet></router-outlet>

================================================
File: app.component.spec.ts
================================================
import { TestBed } from '@angular/core/testing';
import { AppComponent } from './app.component';

describe('AppComponent', () => {
  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [AppComponent],
    }).compileComponents();
  });

  it('should create the app', () => {
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.componentInstance;
    expect(app).toBeTruthy();
  });

  it(`should have the 'kyl' title`, () => {
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.componentInstance;
    expect(app.title).toEqual('kyl');
  });

  it('should render title', () => {
    const fixture = TestBed.createComponent(AppComponent);
    fixture.detectChanges();
    const compiled = fixture.nativeElement as HTMLElement;
    expect(compiled.querySelector('h1')?.textContent).toContain('Hello, kyl');
  });
});


================================================
File: app.component.ts
================================================
import { HTTP_INTERCEPTORS } from '@angular/common/http';
import { Component, ErrorHandler } from '@angular/core';
import { NavigationEnd, Router, RouterOutlet } from '@angular/router';
import { RouteLoggingService } from './services/_core/route-logging.service';
import { filter } from 'rxjs';
import { TEST_View } from '../environments/environment.development';
import { AppErrorHandler } from '@core/error-handler/error-handler';
import { AuthInterceptor } from '@core/auth/interception/auth.interceptor';
import { NotificationHandler } from '@core/notification/use-cases/notification.handler';
import { MatSnackBar, MatSnackBarConfig } from '@angular/material/snack-bar';
import { NOTIFICATION_DURATION } from '@core/utils/constants';
import { SnackbarComponent } from '@ui/shared/components/snackbar/snackbar.component';
import { Notification } from '@core/notification/domain/models/notification.model';

@Component({
	selector: 'app-root',
	imports: [RouterOutlet],
	templateUrl: './app.component.html',
	styleUrls: ['./app.component.scss'], // Fix typo: `styleUrl` to `styleUrls`
})
export class AppComponent {
	constructor(
		private router: Router,
		private logger: RouteLoggingService,
		private snackBar$: MatSnackBar,
		private notificationService: NotificationHandler
	) {
		if (TEST_View.routes_log) {
			console.log('🚀 Routes Logging Enabled');
			this.setupRouteLogging();
		}

		this.notificationService.notifications$.subscribe(
			(notifications: Notification[]) => {
				if (notifications) {
					notifications.forEach((notification: Notification) => {
						const config: MatSnackBarConfig = {
							duration: notification?.duration ?? NOTIFICATION_DURATION,
							panelClass: [
								'notification',
								`notification-${notification?.type}`,
							],
							horizontalPosition: 'right',
							verticalPosition: 'top',
							data: notification,
						};
						this.snackBar$.openFromComponent(SnackbarComponent, config);
					});
				}
			}
		);
	}

	private setupRouteLogging() {
		this.router.events
			.pipe(filter((event) => event instanceof NavigationEnd))
			.subscribe((event: any) => {
				this.logger.logRouteHit(`Navigation to: ${event.url}`);
			});
	}
}


================================================
File: app.config.ts
================================================
import {
	ApplicationConfig,
	ErrorHandler,
	provideZoneChangeDetection,
} from '@angular/core';
import {
	provideRouter,
	withComponentInputBinding,
	withHashLocation,
} from '@angular/router';
import { provideAnimations } from '@angular/platform-browser/animations';
import { HTTP_INTERCEPTORS, provideHttpClient } from '@angular/common/http';
import { routes } from './app.routes';
import { provideAnimationsAsync } from '@angular/platform-browser/animations/async';
import { initializeApp, provideFirebaseApp } from '@angular/fire/app';
import { firebaseConfig } from '../environments/firebaseConfig';
import { getAuth, provideAuth } from '@angular/fire/auth';
import { getFirestore, provideFirestore } from '@angular/fire/firestore';
import { AppErrorHandler } from '@core/error-handler/error-handler';
import { NotificationHandler } from '@core/notification/use-cases/notification.handler';
import { HttpErrorInterceptor } from '@core/error-handler/http-error-handler.interceptor';

export const appConfig: ApplicationConfig = {
	providers: [
		provideZoneChangeDetection({ eventCoalescing: true }),
		provideRouter(routes, withComponentInputBinding()),
		provideAnimations(),
		provideAnimationsAsync(),
		provideHttpClient(),
		provideFirebaseApp(() => initializeApp(firebaseConfig)),
		provideAuth(() => getAuth()),
		provideFirestore(() => getFirestore()), // Add Firestore provider
		// {
		// 	provide: ErrorHandler,
		// 	useClass: AppErrorHandler,
		// },
		{
			provide: HTTP_INTERCEPTORS,
			useClass: HttpErrorInterceptor,
			multi: true,
		},
		{
			provide: NotificationHandler,
		},
	],
};


================================================
File: app.routes.ts
================================================
import { Routes } from '@angular/router';

import { LayoutComponent } from '../ui/pages/layout/layout.component';
import { NonAuthGuard } from '@core/auth/guard/non-auth.guard';
import { AuthGuard } from '@core/auth/guard/auth.guard';

export const routes: Routes = [
	{ path: '', redirectTo: 'login', pathMatch: 'full' },
	{
		path: 'login',
		loadComponent: () =>
			import('../ui/pages/login/login.component').then((m) => m.LoginComponent),
		canActivate: [NonAuthGuard],
	},
	{
		path: 'dashboard',
		component: LayoutComponent,
		canActivate: [AuthGuard],
		children: [
			{
				path: '',
				loadComponent: () =>
					import('../ui/pages/layout/layout.component').then(
						(m) => m.LayoutComponent
					),
			},
			{
				path: 'profile',
				loadComponent: () =>
					import('../ui/pages/profile/profile.component').then(
						(m) => m.ProfileComponent
					),
			},
			{
				path: 'errors',
				loadComponent: () =>
					import('../ui/pages/error-test/error-test.component').then(
						(m) => m.ErrorTestComponent
					),
			},
		],
	},
	{ path: '**', redirectTo: 'login' },
];


================================================
File: interface/contact.interface.ts
================================================
export interface IContact {
	id: string;
	firstName: string;
	lastName: string;
	email: string;
	phone: string;
	address: string;
	postalCode: string;
	city: string;
	country: string;
	message: string;
}


================================================
File: services/_core/auth/auth.explain.txt
================================================
Secure Authentication Implementation Guide
===========================================

This guide explains the implementation of a Hybrid Authentication approach using HttpOnly cookies for refreshToken and in-memory refreshToken storage.

Security Overview
----------------
1. HttpOnly Cookie (refreshToken):
   - Protected from XSS via HttpOnly attribute
   - HTTPS-only transmission
   - SameSite protection against CSRF
   - Server-side validation

2. In-Memory Token (refreshToken):
   - Non-persistent storage
   - Short lifespan
   - Cleared on page reload
   - XSS protection

Key Security Features
-------------------
1. Token Rotation
   - New token pair on refresh
   - Server-side invalidation

2. Automatic Session Management
   - Forced logout on invalid tokens
   - Server-side validation

3. Protection Against Common Threats
   - XSS Protection:
     * HttpOnly cookies
     * Memory-only storage
     * Content Security Policy
   
   - CSRF Protection:
     * SameSite cookie attributes
     * CSRF tokens
   
   - Token Security:
     * Short lifespans
     * HTTPS enforcement
     * Token blacklisting

Implementation Guidelines
-----------------------
1. HTTPS Configuration
   - Mandatory for all token operations
   - Secure cookie attributes

2. Token Lifecycle
   - refreshToken: 15-minute lifespan
   - refreshToken: 7-day lifespan
   - Automatic rotation

3. Security Measures
   - Server-side validation
   - Minimal token scopes
   - Strong CSP implementation
   - Activity monitoring
   - Audit logging

Best Practices
-------------
1. Token Management
   - Regular rotation
   - Automatic invalidation
   - Secure storage

2. Monitoring
   - Usage patterns
   - Suspicious activity
   - Token revocation capability

3. Implementation
   - Least privilege principle
   - Comprehensive logging
   - Regular security audits

================================================
File: services/_core/auth/auth.service.spec.ts
================================================
import { TestBed } from '@angular/core/testing';

import { AuthService } from './auth.service';

describe('AuthService', () => {
  let service: AuthService;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(AuthService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});


================================================
File: services/_core/auth/auth.service.ts
================================================
import { Injectable } from '@angular/core';
import {
	Auth,
	GoogleAuthProvider,
	signInWithPopup,
	User,
} from '@angular/fire/auth';
import { Router } from '@angular/router';
import {
	BehaviorSubject,
	firstValueFrom,
	from,
	Observable,
	throwError,
} from 'rxjs';
import { catchError, finalize, map, switchMap, tap } from 'rxjs/operators';
import { RestService } from '../rest/rest.service';
import { TokenService } from '../token/token.service';

@Injectable({
	providedIn: 'root',
})
export class AuthService {
	private userSubject = new BehaviorSubject<User | undefined>(undefined);
	private refreshTokenTimeout?: any;
	private isRefreshing = false;
	private initialCheckDone = false;
	readonly user$ = this.userSubject.asObservable();

	constructor(
		private restService: RestService,
		private router: Router,
		private tokenService: TokenService,
		private auth: Auth
	) {
		this.checkAuthStatus();
		// Listen to Firebase auth state changes
		this.auth.onAuthStateChanged((user) => {
			if (user) {
				// Get fresh tokens when auth state changes
				this.refreshUserTokens(user);
			} else {
				this.clearSession();
			}
		});
	}

	getCookie(name: string): string | null {
		const value = `; ${document.cookie}`;
		const parts = value.split(`; ${name}=`);
		if (parts.length === 2) {
			return parts.pop()?.split(';').shift() || null;
		}
		return null;
	}

	// Method to update user state
	updateUser(user: User | undefined): void {
		this.userSubject.next(user);
	}

	private async refreshUserTokens(user: User): Promise<void> {
		try {
			const idToken = await user.getIdToken(true);
			const userCredential = await this.auth.currentUser?.getIdTokenResult();

			if (userCredential) {
				await this.handleFirebaseUser(user, idToken);
			}
		} catch (error) {
			console.error('Error refreshing tokens:', error);
			this.clearSession();
		}
	}

	private async handleFirebaseUser(
		firebaseUser: User,
		idToken: string
	): Promise<void> {
		try {
			// First, set the tokens via backend
			await firstValueFrom(
				this.tokenService.setTokens({
					idToken,
					refreshToken: (firebaseUser as User).refreshToken || '',
				})
			);

			// Then proceed with session creation
			this.restService.get('/auth/current').subscribe({
				next: (response) => {
					const authUser: User = Object.assign({}, firebaseUser);
					this.userSubject.next(authUser);
					this.startRefreshTokenTimer();
				},
				error: (error) => {
					console.error('Error setting session:', error);
					this.clearSession();
				},
			});
		} catch (error) {
			console.error('Error handling Firebase user:', error);
			this.clearSession();
		}
	}

	private verifyFirebaseToken(token: string): Observable<User> {
		return this.restService.post<User>('/auth/current', {
			token,
		});
	}

	async signInWithGoogle(): Promise<void> {
		try {
			const provider = new GoogleAuthProvider();
			const result = await signInWithPopup(this.auth, provider);
			console.log('result', result);
			// Get fresh tokens after sign in
			const idToken = await result.user.getIdToken(true);
			const refreshToken = (result as any)._tokenResponse?.refreshToken || '';
			console.log('idToken', idToken);
			console.log('refreshToken', refreshToken);
			await this.handleFirebaseUser(result.user, idToken);
			this.router.navigate(['/dashboard']);
		} catch (error) {
			console.error('Google sign-in error:', error);
			throw error;
		}
	}

	private checkAuthStatus(): void {
		if (this.initialCheckDone || this.isRefreshing || this.userSubject.value) {
			return;
		}

		const currentUser = this.auth.currentUser;
		if (currentUser) {
			this.refreshUserTokens(currentUser);
		} else {
			this.clearSession();
		}
		this.initialCheckDone = true;
	}

	getCurrentUser(): Observable<any> {
		if (this.userSubject.value) {
			return new Observable((subscriber) => {
				subscriber.next(this.userSubject.value);
				subscriber.complete();
			});
		}

		return this.restService.get<any>('/auth/current').pipe(
			tap((result) => {
				if (!this.userSubject.value) {
					this.userSubject.next(result.data as User);
				}
			}),
			catchError((error) => {
				this.clearSession();
				return throwError(() => error);
			})
		);
	}

	login(email: string, password: string): Observable<any> {
		return this.restService.post<any>('/auth/login', { email, password }).pipe(
			switchMap((response) => {
				if (response && response.success) {
					return this.getCurrentUser().pipe(
						tap(() => {
							this.startRefreshTokenTimer();
							this.router.navigate(['/dashboard']);
						}),
						map(() => response)
					);
				}
				return throwError(() => new Error('Login failed'));
			}),
			catchError((error) => {
				console.error('Login error:', error);
				this.clearSession();
				return throwError(() => error);
			})
		);
	}

	logout(): Observable<void> {
		return new Observable((subscriber) => {
			Promise.all([
				this.auth.signOut(),
				firstValueFrom(this.restService.post<void>('/auth/logout', {})),
			])
				.then(() => {
					this.clearSession();
					this.router.navigate(['/login']);
					subscriber.complete();
				})
				.catch((error) => {
					console.error('Erreur de déconnexion :', error);
					this.clearSession();
					this.router.navigate(['/login']);
					subscriber.error(error);
				});
		});
	}

	private clearSession(): void {
		this.stopRefreshTokenTimer();
		this.tokenService.clearIdToken();
		this.tokenService.clearRefreshTokenOnCookie();
		this.tokenService.clearIdTokenOnCookie();
		this.userSubject.next(undefined);
		this.initialCheckDone = false;
		this.isRefreshing = false;
	}

	isAuthenticated(): boolean {
		return !!this.userSubject.value;
	}

	private startRefreshTokenTimer(): void {
		const refreshInterval = 14 * 60 * 1000;
		this.stopRefreshTokenTimer();
		this.refreshTokenTimeout = setInterval(() => {
			this.refreshToken().subscribe();
		}, refreshInterval);
	}

	refreshToken(): Observable<void> {
		if (this.isRefreshing) {
			return throwError(() => new Error('Token refresh in progress'));
		}

		this.isRefreshing = true;
		const currentUser = this.auth.currentUser;

		if (!currentUser) {
			this.clearSession();
			return throwError(() => new Error('No authenticated user'));
		}

		return from(currentUser.getIdToken(true)).pipe(
			switchMap((token: string) => {
				return from(this.refreshUserTokens(currentUser));
			}),
			catchError((error) => {
				this.clearSession();
				return throwError(() => error);
			}),
			finalize(() => {
				this.isRefreshing = false;
			}),
			map(() => void 0)
		);
	}

	private stopRefreshTokenTimer(): void {
		if (this.refreshTokenTimeout) {
			clearInterval(this.refreshTokenTimeout);
		}
	}

	ngOnDestroy(): void {
		this.stopRefreshTokenTimer();
		this.userSubject.complete();
	}
}


================================================
File: services/_core/rest/rest.service.spec.ts
================================================
import { TestBed } from '@angular/core/testing';

import { RestService } from './rest.service';

describe('RestService', () => {
  let service: RestService;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(RestService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});


================================================
File: services/_core/rest/rest.service.ts
================================================
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { Observable, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { environment } from '../../../../../environments/environment';

@Injectable({
  providedIn: 'root',
})
export class RestService {
  private apiUrl = environment.urlBackend;
  private apiVersion = environment.baseapi;

  constructor(private http: HttpClient) {}

  private createOptions() {
    return {
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
      withCredentials: true, // Important for sending/receiving cookies
    };
  }

  get<T>(endpoint: string): Observable<T> {
    return this.http
      .get<T>(
        `${this.apiUrl}${this.apiVersion}${endpoint}`,
        this.createOptions()
      )
      .pipe(catchError(this.handleError));
  }

  post<T>(endpoint: string, data: any): Observable<T> {
    return this.http
      .post<T>(
        `${this.apiUrl}${this.apiVersion}${endpoint}`,
        data,
        this.createOptions()
      )
      .pipe(catchError(this.handleError));
  }

  put<T>(endpoint: string, data: any): Observable<T> {
    return this.http
      .put<T>(
        `${this.apiUrl}${this.apiVersion}${endpoint}`,
        data,
        this.createOptions()
      )
      .pipe(catchError(this.handleError));
  }

  delete<T>(endpoint: string): Observable<T> {
    return this.http
      .delete<T>(
        `${this.apiUrl}${this.apiVersion}${endpoint}`,
        this.createOptions()
      )
      .pipe(catchError(this.handleError));
  }

  private handleError(error: any) {
    console.error('API Error:', error);
    return throwError(() => error);
  }
}


================================================
File: services/_core/route-logging.service.spec.ts
================================================
import { TestBed } from '@angular/core/testing';

import { RouteLoggingService } from './route-logging.service';

describe('RouteLoggingService', () => {
  let service: RouteLoggingService;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(RouteLoggingService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});


================================================
File: services/_core/route-logging.service.ts
================================================
import { Injectable } from '@angular/core';

@Injectable({
	providedIn: 'root',
})
export class RouteLoggingService {
	logRouteHit(route: string) {
		console.log(`🛣️ Route Hit: ${route}`);
	}

	logGuardCheck(guardName: string, path: string) {
		console.log(`🛡️ ${guardName} Check - Path: ${path}`);
	}

	logGuardResult(guardName: string, result: boolean) {
		console.log(
			`🔒 ${guardName} Result: ${result ? '✅ Allowed' : '❌ Blocked'}`
		);
	}
}


================================================
File: services/_core/token/token.service.spec.ts
================================================
import { TestBed } from '@angular/core/testing';

import { TokenService } from './token.service';

describe('RestService', () => {
  let service: TokenService;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(TokenService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});


================================================
File: services/_core/token/token.service.ts
================================================
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError, map, retry, tap, timeout } from 'rxjs/operators';
import { environment } from '../../../../../environments/environment';
import { RestService } from '../rest/rest.service';

@Injectable({
	providedIn: 'root',
})
export class TokenService {
	private idToken: string | null = null; // Stored in memory

	constructor(private restService: RestService) {}

	// Get the ID Token
	getIdToken(): string | null {
		return this.idToken;
	}

	// Set the ID Token
	setIdToken(token: string): void {
		this.idToken = token;
	}

	// Clear the ID Token
	clearIdToken(): void {
		this.idToken = null;
	}

	clearIdTokenOnCookie(): void {
		console.log('clearIdTokenOnCookie');
		const cookieName = 'idToken';
		document.cookie = `${cookieName}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;`;
	}

	clearRefreshTokenOnCookie(): void {
		console.log('clearRefreshTokenOnCookie');
		const cookieName = 'refreshToken';
		document.cookie = `${cookieName}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;`;
	}

	// Refresh the ID Token using HttpOnly cookie
	refreshIdToken(): Observable<string> {
		return this.restService.get<{ idToken: string }>(`/auth/refreshtoken`).pipe(
			retry(1), // Add retry for network issues
			timeout(5000), // Add timeout
			tap((response: any) => {
				this.setIdToken(response.idToken);
			}),
			catchError((error) => {
				this.clearIdToken();
				return throwError(() => error);
			})
		);
	}

	setTokens(tokens: { idToken: string; refreshToken: string }) {
		// The actual token storage will be handled by your backend
		return this.restService.post(`/auth/set-tokens`, tokens);
	}
}


================================================
File: services/error-test/error-test.service.spec.ts
================================================
import { TestBed } from '@angular/core/testing';

import { ErrorTestService } from './error-test.service';

describe('ErrorTestService', () => {
  let service: ErrorTestService;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(ErrorTestService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});


================================================
File: services/error-test/error-test.service.ts
================================================
// error-test.service.ts
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { environment } from '../../../../environments/environment';

@Injectable({
	providedIn: 'root',
})
export class ErrorTestService {
	private apiUrl = environment.urlBackend;

	constructor(private http: HttpClient) {}

	testError(statusCode: number) {
		return this.http.get(`${this.apiUrl}/test-error/${statusCode}`);
	}

	testValidationError() {
		return this.http.post(`${this.apiUrl}/test-error/validation`, {
			email: 'invalid',
			password: '123',
		});
	}

	testNetworkError() {
		// This will cause a network error
		return this.http.get('https://non-existent-domain.example');
	}
}


================================================
File: services/image/image.service.spec.ts
================================================
import { TestBed } from '@angular/core/testing';

import { ImageService } from './image.service';

describe('ImageService', () => {
  let service: ImageService;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(ImageService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});


================================================
File: services/image/image.service.ts
================================================
import { Injectable } from '@angular/core';
import { DomSanitizer, SafeUrl } from '@angular/platform-browser';
import { Observable, of } from 'rxjs';

@Injectable({
	providedIn: 'root',
})
export class ImageService {
	constructor(private sanitizer: DomSanitizer) {}

	convertBase64ToSafeUrl(base64String: string): SafeUrl {
		if (!base64String) {
			return 'assets/images/avatar.png';
		}
		try {
			return this.sanitizer.bypassSecurityTrustUrl(base64String);
		} catch (error) {
			console.error('Error converting base64 to safe URL:', error);
			return 'assets/images/avatar.png';
		}
	}

	// Convert base64 string to Blob
	base64ToBlob(base64: string): Blob {
		try {
			const byteString = atob(base64);
			const arrayBuffer = new ArrayBuffer(byteString.length);
			const uint8Array = new Uint8Array(arrayBuffer);

			for (let i = 0; i < byteString.length; i++) {
				uint8Array[i] = byteString.charCodeAt(i);
			}

			return new Blob([arrayBuffer], { type: 'image/png' });
		} catch (error) {
			console.error('Error converting base64 to Blob:', error);
			return new Blob();
		}
	}

	// Create an object URL from base64
	createObjectUrlFromBase64(base64: string): Observable<string> {
		try {
			const blob = this.base64ToBlob(base64);
			return of(URL.createObjectURL(blob));
		} catch (error) {
			console.error('Error creating object URL:', error);
			return of('');
		}
	}
}


================================================
File: services/profile-service/profile.interface.ts
================================================
export interface Profile {
	email: string;
	firstname: string;
	lastname: string;
	company_name: string;
	address: string;
	siret: string;
	notification: boolean;
	phone: string;
	authProvider?: string;
	linkedAccounts?: string[];
}


================================================
File: services/profile-service/profile.service.spec.ts
================================================
import { TestBed } from '@angular/core/testing';

import { ProfileService } from './profile.service';

describe('ProfileService', () => {
	let service: ProfileService;

	beforeEach(() => {
		TestBed.configureTestingModule({});
		service = TestBed.inject(ProfileService);
	});

	it('should be created', () => {
		expect(service).toBeTruthy();
	});
});


================================================
File: services/profile-service/profile.service.ts
================================================
import { HttpClient } from '@angular/common/http';
import { Injectable, inject, DestroyRef } from '@angular/core';
import { Auth, user } from '@angular/fire/auth';
import { Firestore, doc, docData } from '@angular/fire/firestore';
import {
	Subject,
	Observable,
	takeUntil,
	switchMap,
	throwError,
	map,
} from 'rxjs';
import { Profile } from './profile.interface';
import { RestService } from '../_core/rest/rest.service';
import { AuthService } from '../_core/auth/auth.service';
import { IContact } from '../../interface/contact.interface';

@Injectable({
	providedIn: 'root',
})
export class ProfileService {
	private restService: RestService = inject(RestService);
	private authService: AuthService = inject(AuthService);
	private firestore: Firestore = inject(Firestore);
	private readonly destroy$ = new Subject<void>();
	private apiUrl = 'your-backend-url/api';

	constructor(private http: HttpClient) {
		inject(DestroyRef).onDestroy(() => {
			this.destroy$.next();
			this.destroy$.complete();
		});
	}

	// Keep simple reads direct from Firestore
	getProfile(): Observable<any> {
		const user = this.authService.getCurrentUser();
		return this.restService.get<IContact>(`/contact`);
	}

	// Move sensitive operations to backend
	updateProfile(profile: Partial<Profile>): Observable<Profile> {
		return this.restService.put<Profile>(`/profile`, profile);
	}

	updatePassword(
		currentPassword: string,
		newPassword: string
	): Observable<void> {
		return this.restService.post<void>(`/profile/password`, {
			currentPassword,
			newPassword,
		});
	}

	linkWithGoogle(): Observable<void> {
		return this.restService.post<void>(`/profile/link/google`, {});
	}

	unlinkProvider(providerId: string): Observable<void> {
		return this.restService.post<void>(`/profile/unlink/${providerId}`, {});
	}

	switchNotificationState(): Observable<boolean> {
		return this.restService.post<boolean>(`/profile/notifications/toggle`, {});
	}
}

